{"version":3,"file":"use-merge-state.modern.js","sources":["../src/guards.ts","../src/utils/merge.ts","../src/hooks/use-merge-state.ts","../src/utils/get-return-value.ts"],"sourcesContent":["import { PlainFunction, PlainObject, Unpack } from \"./types\"\n\nexport const isArray = Array.isArray\n\nexport function isFunction<T extends PlainFunction>(\n  value: T | unknown\n): value is PlainFunction<Unpack<Parameters<T>>, ReturnType<T>> {\n  return value instanceof Function\n}\n\nexport function isMap<T, U>(value: Map<T, U> | unknown): value is Map<T, U> {\n  return value instanceof Map\n}\n\nexport function isNumber(value: number | unknown): value is number {\n  return typeof value === \"number\"\n}\n\nexport function isPlainObject<T, U extends PlainObject>(\n  value: PlainObject<T> | U | unknown\n): value is PlainObject<T> | U {\n  return typeof value === \"object\" && value?.constructor === Object\n}\n\nexport function isSet<T>(value: Set<T> | unknown): value is Set<T> {\n  return value instanceof Set\n}\n","import { isArray, isMap, isPlainObject, isSet } from \"../guards\"\nimport { PlainObject, Spread } from \"../types\"\n\ninterface MergeArrays {\n  <A, B>(a: A[], b: B[]): (A | B)[]\n}\n\ninterface MergePlainObjects {\n  <A extends PlainObject, B extends PlainObject>(a: A, b: B): Spread<A, B>\n}\n\ninterface MergeMaps {\n  <A, B, C, D>(a: Map<A, C>, b: Map<B, D>): Map<A | B, C | D>\n}\n\ninterface MergeSets {\n  <A, B>(a: Set<A>, b: Set<B>): Set<A | B>\n}\n\ninterface Merge extends MergeArrays, MergePlainObjects, MergeMaps, MergeSets {\n  <A, B>(a: A, b: B): B\n}\n\nconst mergeArrays: MergeArrays = <A, B>(a: A[], b: B[]) => {\n  return [...a, ...b]\n}\n\nconst mergePlainObjects: MergePlainObjects = <\n  A extends PlainObject,\n  B extends PlainObject\n>(\n  a: A,\n  b: B\n) => {\n  return { ...a, ...b }\n}\n\nconst mergeMaps: MergeMaps = <A, B, C, D>(a: Map<A, C>, b: Map<B, D>) => {\n  return new Map([...a, ...b] as [A | B, C | D][])\n}\n\nconst mergeSets: MergeSets = <A, B>(a: Set<A>, b: Set<B>) => {\n  return new Set([...a, ...b])\n}\n\nexport const merge: Merge = (a: any, b: any) => {\n  if (isArray(a) && isArray(b)) {\n    return mergeArrays(a, b)\n  } else if (isPlainObject(a) && isPlainObject(b)) {\n    return mergePlainObjects(a, b)\n  } else if (isMap(a) && isMap(b)) {\n    return mergeMaps(a, b)\n  } else if (isSet(a) && isSet(b)) {\n    return mergeSets(a, b)\n  } else {\n    return b\n  }\n}\n","import { SetStateAction, useCallback, useMemo, useState } from \"react\"\nimport { DispatchWithOptions } from \"../types\"\nimport { getReturnValue } from \"../utils/get-return-value\"\nimport { merge } from \"../utils/merge\"\n\ninterface MergeOptions {\n  merge?: boolean\n}\n\nconst defaultOptions: MergeOptions = {\n  merge: true\n}\n\nexport function useMergeState<S>(\n  initialState: S | (() => S),\n  options?: MergeOptions\n): [S, DispatchWithOptions<SetStateAction<S>, MergeOptions>]\nexport function useMergeState<S = undefined>(): [\n  S | undefined,\n  DispatchWithOptions<SetStateAction<S | undefined>, MergeOptions>\n]\nexport function useMergeState<S>(\n  initialState?: any,\n  options: MergeOptions = defaultOptions\n): [S, DispatchWithOptions<SetStateAction<S>>] {\n  const [state, setState] = useState<S>(initialState)\n  const instanceOptions = useMemo(\n    () => ({ ...defaultOptions, ...options }),\n    [options]\n  )\n\n  const setMergeState: DispatchWithOptions<\n    SetStateAction<S>,\n    MergeOptions\n  > = useCallback(\n    (value: SetStateAction<S>, options?: MergeOptions) => {\n      const updateOptions = { ...instanceOptions, ...options }\n\n      if (updateOptions.merge) {\n        setState((previousState: S) => {\n          return merge(previousState, getReturnValue(value, previousState))\n        })\n      } else {\n        setState(value)\n      }\n    },\n    [instanceOptions]\n  )\n\n  return [state, setMergeState]\n}\n","import { isFunction } from \"../guards\"\n\nexport function getReturnValue<V, A>(\n  value: V | ((...args: A[]) => V),\n  ...args: A[]\n): V {\n  return isFunction(value) ? value(...args) : (value as V)\n}\n"],"names":["isArray","Array","isMap","value","Map","isPlainObject","constructor","Object","isSet","Set","merge","a","b","mergeArrays","mergePlainObjects","mergeMaps","mergeSets","defaultOptions","useMergeState","initialState","options","state","setState","useState","instanceOptions","useMemo","setMergeState","useCallback","updateOptions","previousState","args","Function","isFunction","getReturnValue"],"mappings":"qRAEaA,EAAUC,MAAMD,iBAQbE,EAAYC,GAC1B,OAAOA,aAAiBC,aAOVC,EACdF,GAEA,MAAwB,iBAAVA,UAAsBA,SAAAA,EAAOG,eAAgBC,gBAG7CC,EAASL,GACvB,OAAOA,aAAiBM,ICF1B,MAsBaC,EAAe,CAACC,EAAQC,IAC/BZ,EAAQW,IAAMX,EAAQY,GAvBK,EAAOD,EAAQC,IACvC,IAAID,KAAMC,GAuBRC,CAAYF,EAAGC,GACbP,EAAcM,IAAMN,EAAcO,GArBF,EAI3CD,EACAC,SAEYD,EAAMC,GAeTE,CAAkBH,EAAGC,GACnBV,EAAMS,IAAMT,EAAMU,GAbF,EAAaD,EAAcC,QAC3CR,IAAI,IAAIO,KAAMC,IAahBG,CAAUJ,EAAGC,GACXJ,EAAMG,IAAMH,EAAMI,GAXF,EAAOD,EAAWC,QAClCH,IAAI,IAAIE,KAAMC,IAWhBI,CAAUL,EAAGC,GAEbA,EC9CLK,EAA+B,CACnCP,OAAO,YAWOQ,EACdC,EACAC,EAAwBH,GAExB,MAAOI,EAAOC,GAAYC,EAAYJ,GAChCK,EAAkBC,EACtB,SAAYR,EAAmBG,GAC/B,CAACA,IAGGM,EAGFC,EACF,CAACxB,EAA0BiB,KACzB,MAAMQ,OAAqBJ,EAAoBJ,GAG7CE,EADEM,EAAclB,MACNmB,GACDnB,EAAMmB,WCrCrB1B,KACG2B,GAEH,gBHDA3B,GAEA,OAAOA,aAAiB4B,SGDjBC,CAAW7B,GAASA,KAAS2B,GAAS3B,EDkCT8B,CAAe9B,EAAO0B,IAG3C1B,IAGb,CAACqB,IAGH,MAAO,CAACH,EAAOK"}