{"version":3,"file":"index.module.js","sources":["../src/guards.ts","../src/utils/merge.ts","../src/hooks/use-merge-state.ts","../src/utils/get-return-value.ts"],"sourcesContent":["import { PlainFunction, PlainObject, Unpack } from \"./types\"\n\nexport const isArray = Array.isArray\n\nexport function isFunction<T extends PlainFunction>(\n  value: T | unknown\n): value is PlainFunction<Unpack<Parameters<T>>, ReturnType<T>> {\n  return value instanceof Function\n}\n\nexport function isMap<T, U>(value: Map<T, U> | unknown): value is Map<T, U> {\n  return value instanceof Map\n}\n\nexport function isNumber(value: number | unknown): value is number {\n  return typeof value === \"number\"\n}\n\nexport function isPlainObject<T, U extends PlainObject>(\n  value: PlainObject<T> | U | unknown\n): value is PlainObject<T> | U {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    value.constructor === Object &&\n    Object.getPrototypeOf(value) === Object.prototype\n  )\n}\n\nexport function isSet<T>(value: Set<T> | unknown): value is Set<T> {\n  return value instanceof Set\n}\n","import { isArray, isMap, isPlainObject, isSet } from \"../guards\"\nimport { PlainObject, Spread } from \"../types\"\n\ninterface MergeArrays {\n  <A, B>(a: A[], b: B[]): (A | B)[]\n}\n\ninterface MergePlainObjects {\n  <A extends PlainObject, B extends PlainObject>(a: A, b: B): Spread<A, B>\n}\n\ninterface MergeMaps {\n  <A, B, C, D>(a: Map<A, C>, b: Map<B, D>): Map<A | B, C | D>\n}\n\ninterface MergeSets {\n  <A, B>(a: Set<A>, b: Set<B>): Set<A | B>\n}\n\ninterface Merge extends MergeArrays, MergePlainObjects, MergeMaps, MergeSets {\n  <A, B>(a: A, b: B): B\n}\n\nconst mergeArrays: MergeArrays = <A, B>(a: A[], b: B[]) => {\n  return [...a, ...b]\n}\n\nconst mergePlainObjects: MergePlainObjects = <\n  A extends PlainObject,\n  B extends PlainObject\n>(\n  a: A,\n  b: B\n) => {\n  return { ...a, ...b }\n}\n\nconst mergeMaps: MergeMaps = <A, B, C, D>(a: Map<A, C>, b: Map<B, D>) => {\n  return new Map([...a, ...b] as [A | B, C | D][])\n}\n\nconst mergeSets: MergeSets = <A, B>(a: Set<A>, b: Set<B>) => {\n  return new Set([...a, ...b])\n}\n\nexport const merge: Merge = (a: any, b: any) => {\n  if (isArray(a) && isArray(b)) {\n    return mergeArrays(a, b)\n  } else if (isPlainObject(a) && isPlainObject(b)) {\n    return mergePlainObjects(a, b)\n  } else if (isMap(a) && isMap(b)) {\n    return mergeMaps(a, b)\n  } else if (isSet(a) && isSet(b)) {\n    return mergeSets(a, b)\n  } else {\n    return b\n  }\n}\n","import { SetStateAction, useCallback, useMemo, useState } from \"react\"\nimport { DispatchWithOptions } from \"../types\"\nimport { getReturnValue } from \"../utils/get-return-value\"\nimport { merge } from \"../utils/merge\"\n\ninterface MergeOptions {\n  merge?: boolean\n}\n\nconst defaultOptions: MergeOptions = {\n  merge: true\n}\n\nexport function useMergeState<S>(\n  initialState: S | (() => S),\n  options?: MergeOptions\n): [S, DispatchWithOptions<SetStateAction<S>, MergeOptions>]\nexport function useMergeState<S = undefined>(): [\n  S | undefined,\n  DispatchWithOptions<SetStateAction<S | undefined>, MergeOptions>\n]\nexport function useMergeState<S>(\n  initialState?: any,\n  options: MergeOptions = defaultOptions\n): [S, DispatchWithOptions<SetStateAction<S>>] {\n  const [state, setState] = useState<S>(initialState)\n  const instanceOptions = useMemo(\n    () => ({ ...defaultOptions, ...options }),\n    [options]\n  )\n\n  const setMergeState: DispatchWithOptions<\n    SetStateAction<S>,\n    MergeOptions\n  > = useCallback(\n    (value: SetStateAction<S>, options?: MergeOptions) => {\n      const updateOptions = { ...instanceOptions, ...options }\n\n      if (updateOptions.merge) {\n        setState((previousState: S) => {\n          return merge(previousState, getReturnValue(value, previousState))\n        })\n      } else {\n        setState(value)\n      }\n    },\n    [instanceOptions]\n  )\n\n  return [state, setMergeState]\n}\n","import { isFunction } from \"../guards\"\n\nexport function getReturnValue<V, A>(\n  value: V | ((...args: A[]) => V),\n  ...args: A[]\n): V {\n  return isFunction(value) ? value(...args) : (value as V)\n}\n"],"names":["isArray","Array","isFunction","value","Function","isMap","Map","isPlainObject","constructor","Object","getPrototypeOf","prototype","isSet","Set","merge","a","b","mergeArrays","mergePlainObjects","mergeMaps","mergeSets","defaultOptions","useMergeState","initialState","options","useState","state","setState","instanceOptions","useMemo","setMergeState","useCallback","updateOptions","previousState","getReturnValue"],"mappings":"mRAEaA,EAAUC,MAAMD,iBAEbE,EACdC,GAEA,OAAOA,aAAiBC,kBAGVC,EAAYF,GAC1B,OAAOA,aAAiBG,aAOVC,EACdJ,GAEA,MACmB,iBAAVA,GACG,OAAVA,GACAA,EAAMK,cAAgBC,QACtBA,OAAOC,eAAeP,KAAWM,OAAOE,mBAI5BC,EAAST,GACvB,OAAOA,aAAiBU,ICP1B,IAsBaC,EAAe,SAACC,EAAQC,GACnC,OAAIhB,EAAQe,IAAMf,EAAQgB,GAvBK,SAAOD,EAAQC,GAC9C,gBAAWD,EAAMC,GAuBRC,CAAYF,EAAGC,GACbT,EAAcQ,IAAMR,EAAcS,GArBF,SAI3CD,EACAC,GAEA,YAAYD,EAAMC,GAeTE,CAAkBH,EAAGC,GACnBX,EAAMU,IAAMV,EAAMW,GAbF,SAAaD,EAAcC,GACtD,WAAWV,cAAQS,EAAMC,IAahBG,CAAUJ,EAAGC,GACXJ,EAAMG,IAAMH,EAAMI,GAXF,SAAOD,EAAWC,GAC7C,WAAWH,cAAQE,EAAMC,IAWhBI,CAAUL,EAAGC,GAEbA,GC9CLK,EAA+B,CACnCP,OAAO,YAWOQ,EACdC,EACAC,YAAAA,IAAAA,EAAwBH,GAExB,MAA0BI,EAAYF,GAA/BG,OAAOC,OACRC,EAAkBC,EACtB,uBAAYR,EAAmBG,IAC/B,CAACA,IAGGM,EAGFC,EACF,SAAC5B,EAA0BqB,GACzB,IAAMQ,OAAqBJ,EAAoBJ,GAG7CG,EADEK,EAAclB,MACP,SAACmB,GACR,OAAOnB,EAAMmB,WCrCrB9B,GAGA,OAAOD,EAAWC,GAASA,2CAAkBA,EDkCT+B,CAAe/B,EAAO8B,KAG3C9B,IAGb,CAACyB,IAGH,MAAO,CAACF,EAAOI"}