import{useState as t,useMemo as n,useCallback as r}from"react";function e(){return e=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e])}return t},e.apply(this,arguments)}const o=Array.isArray;function c(t){return t instanceof Map}function u(t){return"object"==typeof t&&null!==t&&t.constructor===Object&&Object.getPrototypeOf(t)===Object.prototype}function i(t){return t instanceof Set}const f=(t,n)=>o(t)&&o(n)?((t,n)=>[...t,...n])(t,n):u(t)&&u(n)?((t,n)=>e({},t,n))(t,n):c(t)&&c(n)?((t,n)=>new Map([...t,...n]))(t,n):i(t)&&i(n)?((t,n)=>new Set([...t,...n]))(t,n):n,a={merge:!0};function p(o,c=a){const[u,i]=t(o),p=n(()=>e({},a,c),[c]),s=r((t,n)=>{const r=e({},p,n);i(r.merge?n=>f(n,function(t,...n){return function(t){return t instanceof Function}(t)?t(...n):t}(t,n)):t)},[p]);return[u,s]}export{f as merge,p as useMergeState};
//# sourceMappingURL=index.mjs.map
