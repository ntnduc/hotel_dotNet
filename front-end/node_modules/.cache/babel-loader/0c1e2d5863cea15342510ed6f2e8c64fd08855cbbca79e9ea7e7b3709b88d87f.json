{"ast":null,"code":"import { useState as n, useMemo as t, useCallback as r } from \"react\";\nfunction e() {\n  return e = Object.assign || function (n) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n      for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (n[e] = r[e]);\n    }\n    return n;\n  }, e.apply(this, arguments);\n}\nvar o = Array.isArray;\nfunction c(n) {\n  return n instanceof Function;\n}\nfunction u(n) {\n  return n instanceof Map;\n}\nfunction i(n) {\n  return \"object\" == typeof n && null !== n && n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype;\n}\nfunction a(n) {\n  return n instanceof Set;\n}\nvar f = function (n, t) {\n    return o(n) && o(t) ? function (n, t) {\n      return [].concat(n, t);\n    }(n, t) : i(n) && i(t) ? function (n, t) {\n      return e({}, n, t);\n    }(n, t) : u(n) && u(t) ? function (n, t) {\n      return new Map([].concat(n, t));\n    }(n, t) : a(n) && a(t) ? function (n, t) {\n      return new Set([].concat(n, t));\n    }(n, t) : t;\n  },\n  p = {\n    merge: !0\n  };\nfunction l(o, u) {\n  void 0 === u && (u = p);\n  var i = n(o),\n    a = i[0],\n    l = i[1],\n    s = t(function () {\n      return e({}, p, u);\n    }, [u]),\n    v = r(function (n, t) {\n      var r = e({}, s, t);\n      l(r.merge ? function (t) {\n        return f(t, function (n) {\n          return c(n) ? n.apply(void 0, [].slice.call(arguments, 1)) : n;\n        }(n, t));\n      } : n);\n    }, [s]);\n  return [a, v];\n}\nexport { f as merge, l as useMergeState };","map":{"version":3,"names":["o","Array","isArray","c","n","Function","u","Map","i","constructor","Object","getPrototypeOf","prototype","a","Set","f","merge","t","concat","e","p","l","s","v","r","apply","slice","call","arguments","useMergeState"],"sources":["/Users/nguyentrannhatduc/Documents/Github/hotel_dotNet/front-end/node_modules/use-merge-state/src/guards.ts","/Users/nguyentrannhatduc/Documents/Github/hotel_dotNet/front-end/node_modules/use-merge-state/src/utils/merge.ts","/Users/nguyentrannhatduc/Documents/Github/hotel_dotNet/front-end/node_modules/use-merge-state/src/hooks/use-merge-state.ts","/Users/nguyentrannhatduc/Documents/Github/hotel_dotNet/front-end/node_modules/use-merge-state/src/utils/get-return-value.ts"],"sourcesContent":["import { PlainFunction, PlainObject, Unpack } from \"./types\"\n\nexport const isArray = Array.isArray\n\nexport function isFunction<T extends PlainFunction>(\n  value: T | unknown\n): value is PlainFunction<Unpack<Parameters<T>>, ReturnType<T>> {\n  return value instanceof Function\n}\n\nexport function isMap<T, U>(value: Map<T, U> | unknown): value is Map<T, U> {\n  return value instanceof Map\n}\n\nexport function isNumber(value: number | unknown): value is number {\n  return typeof value === \"number\"\n}\n\nexport function isPlainObject<T, U extends PlainObject>(\n  value: PlainObject<T> | U | unknown\n): value is PlainObject<T> | U {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    value.constructor === Object &&\n    Object.getPrototypeOf(value) === Object.prototype\n  )\n}\n\nexport function isSet<T>(value: Set<T> | unknown): value is Set<T> {\n  return value instanceof Set\n}\n","import { isArray, isMap, isPlainObject, isSet } from \"../guards\"\nimport { PlainObject, Spread } from \"../types\"\n\ninterface MergeArrays {\n  <A, B>(a: A[], b: B[]): (A | B)[]\n}\n\ninterface MergePlainObjects {\n  <A extends PlainObject, B extends PlainObject>(a: A, b: B): Spread<A, B>\n}\n\ninterface MergeMaps {\n  <A, B, C, D>(a: Map<A, C>, b: Map<B, D>): Map<A | B, C | D>\n}\n\ninterface MergeSets {\n  <A, B>(a: Set<A>, b: Set<B>): Set<A | B>\n}\n\ninterface Merge extends MergeArrays, MergePlainObjects, MergeMaps, MergeSets {\n  <A, B>(a: A, b: B): B\n}\n\nconst mergeArrays: MergeArrays = <A, B>(a: A[], b: B[]) => {\n  return [...a, ...b]\n}\n\nconst mergePlainObjects: MergePlainObjects = <\n  A extends PlainObject,\n  B extends PlainObject\n>(\n  a: A,\n  b: B\n) => {\n  return { ...a, ...b }\n}\n\nconst mergeMaps: MergeMaps = <A, B, C, D>(a: Map<A, C>, b: Map<B, D>) => {\n  return new Map([...a, ...b] as [A | B, C | D][])\n}\n\nconst mergeSets: MergeSets = <A, B>(a: Set<A>, b: Set<B>) => {\n  return new Set([...a, ...b])\n}\n\nexport const merge: Merge = (a: any, b: any) => {\n  if (isArray(a) && isArray(b)) {\n    return mergeArrays(a, b)\n  } else if (isPlainObject(a) && isPlainObject(b)) {\n    return mergePlainObjects(a, b)\n  } else if (isMap(a) && isMap(b)) {\n    return mergeMaps(a, b)\n  } else if (isSet(a) && isSet(b)) {\n    return mergeSets(a, b)\n  } else {\n    return b\n  }\n}\n","import { SetStateAction, useCallback, useMemo, useState } from \"react\"\nimport { DispatchWithOptions } from \"../types\"\nimport { getReturnValue } from \"../utils/get-return-value\"\nimport { merge } from \"../utils/merge\"\n\ninterface MergeOptions {\n  merge?: boolean\n}\n\nconst defaultOptions: MergeOptions = {\n  merge: true\n}\n\nexport function useMergeState<S>(\n  initialState: S | (() => S),\n  options?: MergeOptions\n): [S, DispatchWithOptions<SetStateAction<S>, MergeOptions>]\nexport function useMergeState<S = undefined>(): [\n  S | undefined,\n  DispatchWithOptions<SetStateAction<S | undefined>, MergeOptions>\n]\nexport function useMergeState<S>(\n  initialState?: any,\n  options: MergeOptions = defaultOptions\n): [S, DispatchWithOptions<SetStateAction<S>>] {\n  const [state, setState] = useState<S>(initialState)\n  const instanceOptions = useMemo(\n    () => ({ ...defaultOptions, ...options }),\n    [options]\n  )\n\n  const setMergeState: DispatchWithOptions<\n    SetStateAction<S>,\n    MergeOptions\n  > = useCallback(\n    (value: SetStateAction<S>, options?: MergeOptions) => {\n      const updateOptions = { ...instanceOptions, ...options }\n\n      if (updateOptions.merge) {\n        setState((previousState: S) => {\n          return merge(previousState, getReturnValue(value, previousState))\n        })\n      } else {\n        setState(value)\n      }\n    },\n    [instanceOptions]\n  )\n\n  return [state, setMergeState]\n}\n","import { isFunction } from \"../guards\"\n\nexport function getReturnValue<V, A>(\n  value: V | ((...args: A[]) => V),\n  ...args: A[]\n): V {\n  return isFunction(value) ? value(...args) : (value as V)\n}\n"],"mappings":";;;;;;;;;;IAEaA,CAAA,GAAUC,KAAA,CAAMC,OAAA;AAAA,SAEbC,EACdC,CAAA;EAEA,OAAOA,CAAA,YAAiBC,QAAA;AAAA;AAAA,SAGVC,EAAYF,CAAA;EAC1B,OAAOA,CAAA,YAAiBG,GAAA;AAAA;AAAA,SAOVC,EACdJ,CAAA;EAEA,OACmB,mBAAVA,CAAA,IACG,SAAVA,CAAA,IACAA,CAAA,CAAMK,WAAA,KAAgBC,MAAA,IACtBA,MAAA,CAAOC,cAAA,CAAeP,CAAA,MAAWM,MAAA,CAAOE,SAAA;AAAA;AAAA,SAI5BC,EAAST,CAAA;EACvB,OAAOA,CAAA,YAAiBU,GAAA;AAAA;ACP1B,IAsBaC,CAAA,GAAe,SAAAC,CAACZ,CAAA,EAAQa,CAAA;IACnC,OAAIjB,CAAA,CAAQI,CAAA,KAAMJ,CAAA,CAAQiB,CAAA,IAvBK,UAAOb,CAAA,EAAQa,CAAA;MAC9C,UAAAC,MAAA,CAAWd,CAAA,EAAMa,CAAA;IAAA,CAuBR,CAAYb,CAAA,EAAGa,CAAA,IACbT,CAAA,CAAcJ,CAAA,KAAMI,CAAA,CAAcS,CAAA,IArBF,UAI3Cb,CAAA,EACAa,CAAA;MAEA,OAAAE,CAAA,KAAYf,CAAA,EAAMa,CAAA;IAAA,CAeT,CAAkBb,CAAA,EAAGa,CAAA,IACnBX,CAAA,CAAMF,CAAA,KAAME,CAAA,CAAMW,CAAA,IAbF,UAAab,CAAA,EAAca,CAAA;MACtD,WAAWV,GAAA,IAAAW,MAAA,CAAQd,CAAA,EAAMa,CAAA;IAAA,CAahB,CAAUb,CAAA,EAAGa,CAAA,IACXJ,CAAA,CAAMT,CAAA,KAAMS,CAAA,CAAMI,CAAA,IAXF,UAAOb,CAAA,EAAWa,CAAA;MAC7C,WAAWH,GAAA,IAAAI,MAAA,CAAQd,CAAA,EAAMa,CAAA;IAAA,CAWhB,CAAUb,CAAA,EAAGa,CAAA,IAEbA,CAAA;EAAA;EC9CLG,CAAA,GAA+B;IACnCJ,KAAA,GAAO;EAAA;AAAA,SAWOK,EACdrB,CAAA,EACAM,CAAA;EAAA,WAAAA,CAAA,KAAAA,CAAA,GAAwBc,CAAA;EAExB,IAAAZ,CAAA,GAA0BJ,CAAA,CAAYJ,CAAA;IAA/Ba,CAAA,GAAAL,CAAA;IAAOa,CAAA,GAAAb,CAAA;IACRc,CAAA,GAAkBL,CAAA,CACtB;MAAA,OAAAE,CAAA,KAAYC,CAAA,EAAmBd,CAAA;IAAA,GAC/B,CAACA,CAAA;IAGGiB,CAAA,GAGFC,CAAA,CACF,UAACpB,CAAA,EAA0Ba,CAAA;MACzB,IAAMO,CAAA,GAAAL,CAAA,KAAqBG,CAAA,EAAoBL,CAAA;MAG7CI,CAAA,CADEG,CAAA,CAAcR,KAAA,GACP,UAACC,CAAA;QACR,OAAOF,CAAA,CAAME,CAAA,YCrCrBb,CAAA;UAGA,OAAOD,CAAA,CAAWC,CAAA,IAASA,CAAA,CAAAqB,KAAA,YAAAC,KAAA,CAAAC,IAAA,CAAAC,SAAA,QAAkBxB,CAAA;QAAA,CDkCT,CAAeA,CAAA,EAAOa,CAAA;MAAA,IAG3Cb,CAAA;IAAA,GAGb,CAACkB,CAAA;EAGH,OAAO,CAACT,CAAA,EAAOU,CAAA;AAAA;AAAA,SAAAR,CAAA,IAAAC,KAAA,EAAAK,CAAA,IAAAQ,aAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}